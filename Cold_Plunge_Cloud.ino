/* 
  Sketch generated by the Arduino IoT Cloud Thing "Untitled"
  https://create.arduino.cc/cloud/things/60720913-b53e-4844-a619-2fff14b3b990 

  Arduino IoT Cloud Variables description

  The following variables are automatically generated and updated when changes are made to the Thing

  String next_cycle;
  String next_ozone;
  float chiller_current;
  float flow_rate;
  float temp_current;
  int temp_setpoint;
  bool chiller_on;
  bool flow_fail_detected;
  bool ozone_eligible;
  bool ozone_on;
  bool pump_on;

  Variables which are marked as READ/WRITE in the Cloud Thing will also have functions
  which are called when their values are changed from the Dashboard.
  These functions are generated with the Thing and added at the end of this sketch.
*/

#include "ColdPlungeConstants.h"          // A place to store constants for this project
#include "thingProperties.h"
#include <SchedTask.h>

template<class T> inline Print &operator <<(Print &obj, T arg) { obj.print(arg); return obj; } // allow use of Serial <<

long ozone_last_completed;  // The millis when ozone last finished

void startCycle();
void endCycle();
long cycle_start_time;
SchedTask TaskStartCycle (-1, 0, startCycle);
SchedTask TaskEndCycle (-1, 0, endCycle); // Placeholder for task to end cycle

void enableOzone();
void stopOzone();
SchedTask TaskEnableOzone (OZONE_OFFSET, 0, enableOzone);
SchedTask TaskStopOzone (-1, 0, stopOzone);

void flowCheck();
SchedTask TaskFlowCheck (-1, FLOW_CHECK_PERIOD, flowCheck);

float Vo_filtered; // Last filtered ADC input reading
void updateTemp();
SchedTask TaskUpdateTemp(1000, 1000, updateTemp);

void updateCurrent();
SchedTask TaskUpdateCurrent(1000,1000, updateCurrent);

void setup() {
  // Initialize serial and wait for port to open:
  Serial.begin(9600);

  // This delay gives the chance to wait for a Serial Monitor without blocking if none is found
  delay(1500); 

  // Defined in thingProperties.h
  initProperties();

  // Connect to Arduino IoT Cloud
  ArduinoCloud.begin(ArduinoIoTPreferredConnection);
  
  /*
     The following function allows you to obtain more information
     related to the state of network and IoT Cloud connection and errors
     the higher number the more granular information youâ€™ll get.
     The default is 0 (only errors).
     Maximum is 4
 */
  setDebugMessageLevel(2);
  ArduinoCloud.printDebugInfo();

  // START YOUR PROGRAM HERE //
  resetBoard();
  
  // Turn on Pump
  // digitalWrite(PIN_RELAY_CHILLER, HIGH);
  delay(3000); 
  Serial << ts() << " - SETUP COMPLETE\n";
  TaskStartCycle.setNext(MAIN_OFFSET);
}

void loop() {
  ArduinoCloud.update();

  // START YOUR CODE HERE //
  SchedBase::dispatcher();
  
  // Keep next_ozone countdown current in the dashboard
  //Serial << ts() << " - " << millis() << " - " << TaskStartCycle.getNext() << "\n";
  next_cycle = String(
    TaskStartCycle.getNext() == -1 ?
    "Running: " + formatHumanGap(TaskEndCycle.getNext() - millis()) + " left" :
    formatHumanGap(TaskStartCycle.getNext() - millis())
  );
  next_ozone = String(
    ozone_eligible ? 
    "Next Cycle" : 
    String("~ ") + formatHumanGap(TaskEnableOzone.getNext() - millis())
  );



  // chiller_current
  
  // flow_rate

  
  // temp_current = readTemp();


  
}


void startCycle() {
  Serial << ts() << " startCycle\n";
  cycle_start_time = millis();
  
  // Schedule endCycle task
  TaskEndCycle.setNext(MAIN_DURATION_MAX);
  Serial << ts() << " scheduled stopCycle in " << formatHumanGap(MAIN_DURATION_MAX) << "\n";   


  if (flow_fail_detected) {
    Serial << ts() << " >>>> FLOW FAILURE DETECTED - ABORTING startCycle - RESET IN DASHBOARD <<<<\n";
    return;
  }
  
  // Once a cycle starts, we need to schedule its shutdown:
  pump_on = true;
  digitalWrite(PIN_RELAY_PUMP, HIGH);

  // Enable flowcheck after offset delay
  TaskFlowCheck.setNext(FLOW_CHECK_OFFSET); 

  // Ozone
  if(ozone_eligible) {
    ozone_on = true;
    digitalWrite(PIN_RELAY_OZONE, HIGH);
    ozone_eligible = false;
    TaskStopOzone.setNext(OZONE_DURATION);
    Serial << ts() << " Ozone Started - scheduled stopOzone in " << formatHumanGap(OZONE_DURATION) << "\n";   
  } else {
    Serial << ts() << " ozone ineligible for another " << formatHumanGap(TaskEnableOzone.getNext() - millis()) << "\n";
  }

  // Chiller
  if(coolingRequired()) {
    Serial << ts() << " calling for cooling...\n";   
    chiller_on = true;
    digitalWrite(PIN_RELAY_CHILLER, HIGH);

  }

  // Serial << ts() << " TEST " << formatHumanGap(millis() + 10000000) << "\n";   
}

void endCycle() {
  Serial << ts() << " endCycle\n";

  // Clean up cycle
  TaskFlowCheck.setNext(-1);
  Serial << ts() << " disabling flow check\n";  
    
  pump_on = false;
  digitalWrite(PIN_RELAY_PUMP, LOW);

  chiller_on = false;
  digitalWrite(PIN_RELAY_CHILLER, LOW);

  ozone_on = false;
  digitalWrite(PIN_RELAY_OZONE, LOW);  // Should already be off, but just in case of emergency shutdown

  // Schedule next cycle
  TaskStartCycle.setNext(MAIN_GAP);
  
  // Serial << millis() << " END CYCLE - Next Cycle in " << int(TaskStartCycle.getNext()) << "\n";  
  Serial << ts() << " next cycle scheduled in " << formatHumanGap(TaskStartCycle.getNext() - millis()) << "\n";  
  
}

void updateCurrent() {
  int new_current = analogRead(PIN_CURRENT_CHILLER);
  chiller_current = emaFilter(new_current, chiller_current, 0.10);
  //Serial << ts() << " Current: " << new_current << " / " << chiller_current << "\n";
}

void updateTemp() {
  temp_current = round(readTemp() * 10)/10;
  //Serial << ts() << " Updating Temp: " << temp_current << "\n";
}


float readTemp() {
  int Vo = analogRead(PIN_TEMP_SENSOR);
  //Serial << ts() << " analog temp read: " << Vo << " / " << Vo_filtered << "\n";
  Vo_filtered = emaFilter(Vo, Vo_filtered, 0.15);
  
  // Use the smoothed value for calculations
  float R2 = R1 * (1023.0 / (float)Vo_filtered - 1.0); // Resistance of the Thermistor
  float tKelvin = (BETA * ROOM_TEMP) / (BETA + (ROOM_TEMP * log(R2 / Ro)));
  float tCelsius = tKelvin - 273.15;
  float tFahrenheit = (tCelsius * 9.0) / 5.0 + 32.0;
  return tFahrenheit;
}


// TODO Placeholder for if cooling is required...
bool coolingRequired() {
  return temp_current > temp_setpoint;
}


// Make ozone eliglble so it is triggered at start of next cycle
void enableOzone() {
  Serial << ts() << " enableOzone\n";
  ozone_eligible = true;
}

// Turn off Ozone and schedule next cycle
void stopOzone() {
  Serial << ts() << " stopOzone\n";
  ozone_on = false;
  TaskEnableOzone.setNext(OZONE_PERIOD);
  digitalWrite(PIN_RELAY_OZONE, LOW);
}


void flowCheck() {
  // Serial << millis() << " flowCheck\n";
  Serial << ".";
  bool placeholder_check = true;
  if (placeholder_check != true) {
    Serial << ts() << " flowCheck FAILED -- EMERGENCY STOP\n";
    // TODO: Do something to prevent it from restarting immediately...
    flow_fail_detected = true;
    endCycle();
  }
}

// CLEAN UP BOARD AND SET PIN TYPES - CALLED ON STARTUP
void resetBoard() {
  // RELAY SHIELD
  for (int value : ARR_RELAYPINS) {
    pinMode(value, OUTPUT);    // Set pin type
    digitalWrite(value, LOW);  // Turn pin off (should already be default)
  }

  // FLOW METER (HA-1045 flow meter) 
  // https://h2oprotech.com/pages/contact / https://cdn.shopify.com/s/files/1/2175/6387/files/Slide1_c7a65e47-8a9a-493c-8941-cec6dc977bc2.JPG?4198946978217586654
  // Already has 10k pull-up resistor, so use normal digital input
  pinMode(PIN_FLOW_SENSOR, INPUT);
  
  // ANALOG INPUT FOR CURRENT SENSOR
  pinMode(PIN_CURRENT_CHILLER, INPUT);

  // ANALOG INPUT FOR TEMP SENSOR
  pinMode(PIN_TEMP_SENSOR, INPUT);

  Serial << "resetBoard Complete\n";
  
  // CLEAR Cloud Variables
  pump_on = false;
  digitalWrite(PIN_RELAY_PUMP, LOW);  // Turn pin off (should already be default)
  
  ozone_on = false;
  digitalWrite(PIN_RELAY_OZONE, LOW);  // Turn pin off (should already be default)

  chiller_on = false;
  digitalWrite(PIN_RELAY_CHILLER, LOW);  // Turn pin off (should already be default)
  
}

// Does a floating exponential filter to smooth out signals (alpha 0.05 to 0.2)
float emaFilter(float newValue, float &filteredValue, float alpha) {
  // If it's the first run, seed the filtered value
  if (filteredValue <= 0) {
    filteredValue = newValue;
  } else {
    filteredValue = alpha * newValue + (1 - alpha) * filteredValue;
  }
  return filteredValue;
}

// Format timestamp based on current millis
String ts() {
  return formatHumanGap(millis());
}

// Given a gap in ms, return a human readable format
String formatHumanGap(long ms) {
  long hours = ms / (1000 * 60 * 60);
  ms %= (1000 * 60 * 60);
  long minutes = ms / (1000 * 60);
  ms %= (1000 * 60);
  long seconds = ms / 1000;
  ms %= 1000;
  
  // Serial << hours << " - " << minutes << " - " << seconds << "\n";
  String result = String(hours) + "h" + String(minutes) + "m" + String(seconds) + "s";
  return result;
}


/*
  Since PumpOn is READ_WRITE variable, onPumpOnChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onPumpOnChange()  {
  // Add your code here to act upon PumpOn change
  Serial << "IoT Pump Change: " << pump_on << "\n";
  digitalWrite(PIN_RELAY_PUMP, pump_on ? HIGH : LOW);

}

/*
  Since ChillerOn is READ_WRITE variable, onChillerOnChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onChillerOnChange()  {
  // Add your code here to act upon ChillerOn change
  Serial << "IoT Chiller Change: " << chiller_on << "\n";
  digitalWrite(PIN_RELAY_CHILLER, chiller_on ? HIGH : LOW);
}

/*
  Since OzoneOn is READ_WRITE variable, onOzoneOnChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onOzoneOnChange()  {
  // Add your code here to act upon OzoneOn change
  Serial << "IoT Ozone Change: " << ozone_on << "\n";
  digitalWrite(PIN_RELAY_OZONE, ozone_on ? HIGH : LOW);  
}

/*
  Since TempSetpoint is READ_WRITE variable, onTempSetpointChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onTempSetpointChange()  {
  // Add your code here to act upon TempSetpoint change
  Serial << "IoT Setpoint Change: " << temp_setpoint << "\n";
}

/*
  Since TempCurrent is READ_WRITE variable, onTempCurrentChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onTempCurrentChange()  {
  // Add your code here to act upon TempCurrent change
}

/*
  Since OzoneEligible is READ_WRITE variable, onOzoneEligibleChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onOzoneEligibleChange()  {
  // Add your code here to act upon OzoneEligible change
  Serial << "IoT Ozone Eligible Change: " << ozone_eligible << "\n";

}

/*
  Since FlowFailDetected is READ_WRITE variable, onFlowFailDetectedChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onFlowFailDetectedChange()  {
  // Add your code here to act upon FlowFailDetected change
}








